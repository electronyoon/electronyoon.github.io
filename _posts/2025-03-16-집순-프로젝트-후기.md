---
layout: post
title: "집순 프로젝트 후기"
category: reviews
last_modified_at: 2025-03-18
---

1. [부동산은 불편하다](#1-부동산은-불편하다)
2. [컨셉](#2-컨셉)
3. [구현](#3-구현)
4. [챌린지: 선택적 리소스 처리](#4-챌린지-선택적-리소스-처리)
5. [챌린지: 포괄적 요청 추적 시스템](#5-포괄적-요청-추적-시스템)
6. [챌린지: 지오스페이셜 쿼리 성능 향상](#6-지오스페이셜-쿼리-성능-향상)

---

# 1. 부동산은 불편하다

- 저는 네이버 부동산으로 망상하는 걸 좋아합니다. 남의 집을 염탐하며 "저기서는 어떻게 살아볼까" 새로운 삶을 꿈꿔보곤 해요.

- 그런데 그거 아시나요. 가장 개인적이어야 할 내 공간인데도, 내 기호에 딱 맞는 부동산을 찾아주는 서비스는 어디에도 없습니다.

- 네이버 부동산이나 피터팬같은 국내 업체들만을 이야기하는 건 아닙니다. 북미의 유명한 사이트들인 zillow, realtor 등도 마찬가지입니다.

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 1.png" style="width: 100%; height: auto;">

- 다들 이렇게 말하는 듯합니다. "네가 뭘 원하는 지는 모르겠어, 여기 다 줄테니 알아서 체크박스에 클릭해. 방 2개, 에어컨 1개, 욕조 1개."

- 그런데 나에게 맞는 공간이 건축물대장 비스무리한 일람표 하나 있으면 찾아진답니까?

- 누군가는 편의점이 가깝기를, 누군가는 체육시설이 주변에 있기를 바랄 수도 있죠. 누군가는 지하철만 좋아하고 버스는 싫어하지만, 누군가에겐 둘 다 상관 없을 수도 있습니다. 주차장에 물이 잠기는게 무서워 지형상 고지대를 선호할수도 있구요. 상대적으로 제일 낮은 범죄율의 도시에 살고싶어할 수도 있습니다.

- 집순 프로젝트는 이래서 만들어졌습니다.

> 다양한 부동산 정보를 조합해 의사 결정을 돕고 싶다.

---

# 2. 컨셉

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 2.png" style="width: 80%; height: auto;">

- 유저마다 개인화된 매물 점수를 제공하고 싶었습니다.

- 유저에게 여러 가지 `평가 방식`을 제시한 뒤,

- 유저가 스스로 평가 방식을 조합해 나만의 매물 점수를 가지게 하고 싶었습니다.

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 3.png" style="width: 80%; height: auto;">

- 그런데 잘 생각해보면, 평가를 하기 위해서는 데이터가 필요합니다.

- 가령 매물의 공원 접근성을 평가하려면, 적어도 전국에 있는 공원의 위치나 면적 등은 가지고 있어야 하죠.

- 그래서 각 평가의 원천 정보를 수집하고 적재하는 `파이프라인`도 만들기로 했습니다.

---

# 3. 구현

- 집순의 데이터 처리 과정은 네 단계로 구성됩니다.

```
1. 매물 수집 → 2. 평가에 필요한 정보 수집 → 3. 점수 계산 → 4. 정규화
```

- 각 단계는 Job으로 구성돼 있습니다. [DataPipelineService](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/application/pipeline/DataPipelineService.java)가 job을 순서대로 실행합니다. 

<br>

➊ [EstateJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/estate/EstateJobConfig.java): 전국 부동산 매물을 찾아 DB에 저장합니다.
- 이를테면 네이버 부동산에서 네이버 매물을 json으로 가져오는 식이죠. → [NaverLandClient](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/external/naver/NaverLandClient.java)

<br>

➋ [SourceJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/source/SourceJobConfig.java): 점수를 낼 때 필요한 데이터를 DB에 저장합니다.
- 이를테면 전국 공원 정보가 담긴 csv 파일을 Parks 테이블에 저장하는 식이죠. → [ParkSourceCollector](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/source/collector/ParkSourceCollector.java)

<br>

➌ [ScoreJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/score/ScoreJobConfig.java): 특정 척도에 따라 매물별로 점수를 계산합니다.
- 이를테면 공원의 개수, 면적 등을 고려해 11, 20, 19 따위의 점수를 내는 식이죠. → [ParkScoreCalculator](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/score/calculator/ParkScoreCalculator.java)

<br>

➍ [NormalizeJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/normalize/NormalizeJobConfig.java): 계산된 점수를 0-10점 사이로 정규화합니다.
- 이를테면 11, 20, 19 따위의 점수를 5, 10, 7점 따위로 변환하는 식이죠. → [LinearScoreNormalizer](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/normalize/normalizer/LinearScoreNormalizer.java)

<br>

- 각 단계는 수평적 확장에 열려있습니다. 만약 교통이나 편의점 평가 척도를 새로 만들고 싶다면, `TrafficScoreCalculator`나 `ConvstoreScoreCalculator` 등을 만들어 추가하면 됩니다.

---

# 4. 챌린지: 선택적 리소스 처리

### 문제
- SourceJob은 정적 리소스들을 지정된 테이블로 적재합니다.
- 하지만 리소스 개수가 늘어난다면 어떨까요? 매번 전체를 적재하는 과정을 거쳐야 할까요?

### 해결
- '선택적 리소스 처리' 전략을 도입했습니다.
- 리소스의 [변경 여부를 판단](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/application/service/source/collector/SourceCollector.java#L5)하도록 하고, 변경된 것만 적재하는 방식입니다.

### 성과

<div class="chart-container">
  <canvas id="timeImprovementChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  // 테스트 결과 데이터
  const testResults = [
    {resourceCount: 2, timeImprovement: 1.29, memoryImprovement: 1.28, cpuImprovement: 1.10},
    {resourceCount: 4, timeImprovement: 2.12, memoryImprovement: 1.09, cpuImprovement: 0.97},
    {resourceCount: 6, timeImprovement: 2.74, memoryImprovement: 0.62, cpuImprovement: 0.94},
    {resourceCount: 8, timeImprovement: 3.82, memoryImprovement: 1.37, cpuImprovement: 1.19},
    {resourceCount: 10, timeImprovement: 4.44, memoryImprovement: 0.84, cpuImprovement: 0.98},
  ];

  // 리소스 개수별 차트 데이터 준비
  const resourceCounts = testResults.map(r => r.resourceCount);
  const timeImprovementData = testResults.map(r => r.timeImprovement);
  
  // 시간 개선 차트
  new Chart(document.getElementById('timeImprovementChart'), {
    type: 'line',
    data: {
      labels: resourceCounts,
      datasets: [{
        label: '처리 시간 개선',
        data: timeImprovementData,
        borderColor: '#36a2eb',
        backgroundColor: 'rgba(54, 162, 235, 0.2)',
        tension: 0.1
      }]
    },
    options: {
      scales: {
        y: {
          title: {
            display: true,
            text: '시간 개선 (배수)'
          },
          suggestedMin: 1
        },
        x: {
          title: {
            display: true,
            text: '리소스 개수'
          }
        }
      }
    }
  });
});
</script>

<style>
table {
  width: 100%; 
  border-collapse: collapse; 
  margin: 20px 0;
}
table, th, td {
  border: 1px solid #ddd;
}
th, td {
  padding: 4px; 
  text-align: right;
}
th {
  background-color: #f2f2f2;
}
</style>

<table>
  <tr>
    <th>리소스 개수</th>
    <th>전체 처리 시간(ms)</th>
    <th>선택적 처리 시간(ms)</th>
    <th>시간 개선</th>
    <th>메모리 개선</th>
    <th>CPU 개선</th>
  </tr>
  <tr>
    <td>2</td>
    <td>100325</td>
    <td>77813</td>
    <td>1.29배</td>
    <td>1.28배</td>
    <td>1.10배</td>
  </tr>
  <tr>
    <td>4</td>
    <td>158378</td>
    <td>74690</td>
    <td>2.12배</td>
    <td>1.09배</td>
    <td>0.97배</td>
  </tr>
  <tr>
    <td>6</td>
    <td>206643</td>
    <td>75470</td>
    <td>2.74배</td>
    <td>0.62배</td>
    <td>0.94배</td>
  </tr>
  <tr>
    <td>8</td>
    <td>276535</td>
    <td>72399</td>
    <td>3.82배</td>
    <td>1.37배</td>
    <td>1.19배</td>
  </tr>
  <tr>
    <td>10</td>
    <td>351809</td>
    <td>79250</td>
    <td>4.44배</td>
    <td>0.84배</td>
    <td>0.98배</td>
  </tr>
</table>

- 5개의 시나리오에서 '전체 적재'와 '딱 1개만 적재'를 비교했습니다.
- **시간 효율성**: 리소스 개수가 증가할수록 선형적으로 개선됩니다. 리소스가 10개일 때 최대 **4.4배** 개선됩니다.

### 한계
- 파일 시뮬레이션으로 구현했기 때문에, 스프링 환경에서의 트랜잭션 개선사항은 확인하지 못했다는 한계가 있습니다.
- 다양한 수의 column-row를 가진 csv 파일이나, json 파일 등은 확인하지 못했다는 한계가 있습니다.
- 증분 업데이트를 도입하면 효율성을 더 개선할 수 있습니다.

---

# 5. 챌린지: 포괄적 요청 추적 시스템

(작성중)

# 6. 챌린지: 지오스페이셜 쿼리 성능 향상

(작성중)