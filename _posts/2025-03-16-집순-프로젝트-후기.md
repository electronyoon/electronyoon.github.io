---
layout: post
title: "집순 프로젝트 후기"
category: reviews
last_modified_at: 2025-03-19
---

1. [부동산은 불편하다](#1-부동산은-불편하다)
2. [컨셉](#2-컨셉)
3. [구현](#3-구현)
4. [챌린지: 선택적 리소스 처리](#4-챌린지-선택적-리소스-처리)
5. [집순은 어디까지 버틸 수 있을까](#5-집순은-어디까지-버틸-수-있을까)
6. [챌린지: 포괄적 요청 추적 시스템](#6-포괄적-요청-추적-시스템)
7. [챌린지: 지오스페이셜 쿼리 성능 향상](#7-지오스페이셜-쿼리-성능-향상)

---

# 1. 부동산은 불편하다

- 저는 네이버 부동산으로 망상하는 걸 좋아합니다. 남의 집을 염탐하며 "저기서는 어떻게 살아볼까" 새로운 삶을 꿈꿔보곤 해요.

- 그런데 그거 아시나요. 가장 개인적이어야 할 내 공간인데도, 내 기호에 딱 맞는 부동산을 찾아주는 서비스는 어디에도 없습니다.

- 네이버 부동산이나 피터팬같은 국내 업체들만을 이야기하는 건 아닙니다. 북미의 유명한 사이트들인 zillow, realtor 등도 마찬가지입니다.

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 1.png" style="width: 100%; height: auto;">

- 다들 이렇게 말하는 듯합니다. "네가 뭘 원하는 지는 모르겠어, 여기 다 줄테니 알아서 체크박스에 클릭해. 방 2개, 에어컨 1개, 욕조 1개."

- 하지만 이것만으론 부족합니다.

- 누군가는 편의점이 가깝기를, 누군가는 체육시설이 주변에 있기를 바랄 수도 있죠. 누군가는 지하철만 좋아하고 버스는 싫어하지만, 누군가에겐 둘 다 상관 없을 수도 있습니다. 주차장에 물이 잠기는게 무서워 지형상 고지대를 선호할수도 있구요. 상대적으로 제일 낮은 범죄율의 도시에 살고싶어할 수도 있습니다.

- 집순 프로젝트가 만들어진 이유입니다.

  ```
  다양한 부동산 정보를 조합해 의사 결정을 돕고 싶다.
  ```

---

# 2. 컨셉

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 2.png" style="width: 80%; height: auto;">

- 유저마다 개인화된 매물 점수를 제공하고 싶었습니다.

- 유저에게 여러 가지 `평가 방식`을 제시한 뒤,

- 유저가 스스로 평가 방식을 조합해 나만의 매물 점수를 가지게 하고 싶었습니다.

<img src="{{ site.baseurl }}/assets/attachments/2025-03-16/Figure 3.png" style="width: 80%; height: auto;">

- 그런데 잘 생각해보면, 평가를 하기 위해서는 데이터가 필요합니다.

- 가령 매물의 공원 접근성을 평가하려면, 적어도 전국에 있는 공원의 위치나 면적 등은 가지고 있어야 하죠.

- 그래서 각 평가의 원천 정보를 수집하고 적재하는 `파이프라인`도 만들기로 했습니다.

---

# 3. 구현

- 집순의 데이터 처리 과정은 네 단계로 구성됩니다.

```
1. 매물 수집 → 2. 평가에 필요한 정보 수집 → 3. 점수 계산 → 4. 정규화
```

- 각 단계는 Job으로 구성돼 있습니다. [DataPipelineService](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/application/pipeline/DataPipelineService.java)가 job을 순서대로 실행합니다. 

<br>

➊ [EstateJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/estate/EstateJobConfig.java): 전국 부동산 매물을 찾아 DB에 저장합니다.
- 이를테면 네이버 부동산에서 네이버 매물을 json으로 가져오는 식이죠. → [NaverLandClient](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/external/naver/NaverLandClient.java)

<br>

➋ [SourceJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/source/SourceJobConfig.java): 점수를 낼 때 필요한 데이터를 DB에 저장합니다.
- 이를테면 전국 공원 정보가 담긴 csv 파일을 Parks 테이블에 저장하는 식이죠. → [ParkSourceCollector](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/source/collector/ParkSourceCollector.java)

<br>

➌ [ScoreJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/score/ScoreJobConfig.java): 특정 척도에 따라 매물별로 점수를 계산합니다.
- 이를테면 공원의 개수, 면적 등을 고려해 11, 20, 19 따위의 점수를 내는 식이죠. → [ParkScoreCalculator](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/score/calculator/ParkScoreCalculator.java)

<br>

➍ [NormalizeJob](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/job/normalize/NormalizeJobConfig.java): 계산된 점수를 0-10점 사이로 정규화합니다.
- 이를테면 11, 20, 19 따위의 점수를 5, 10, 7점 따위로 변환하는 식이죠. → [LinearScoreNormalizer](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/infrastructure/processor/normalize/normalizer/LinearScoreNormalizer.java)

<br>

- 각 단계는 수평적 확장에 열려있습니다. 만약 교통이나 편의점 평가 척도를 새로 만들고 싶다면, `TrafficScoreCalculator`나 `ConvstoreScoreCalculator` 등을 만들어 추가하면 됩니다.

---

# 4. 챌린지: 선택적 리소스 처리

### i) 문제
- SourceJob은 정적 리소스들을 지정된 테이블로 적재합니다.
- 하지만 리소스 개수가 늘어난다면 어떨까요? 매번 전체를 적재하는 과정을 거쳐야 할까요?

### ii) 해결
- '선택적 리소스 처리' 전략을 도입했습니다.
- 리소스의 [변경 여부를 판단](https://github.com/f-lab-edu/zipsoon/blob/main/batch/src/main/java/com/zipsoon/batch/application/service/source/collector/SourceCollector.java#L5)하도록 하고, 변경된 것만 적재하는 방식입니다.

### iii) 성과

<div class="chart-container">
  <canvas id="timeImprovementChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  // 테스트 결과 데이터
  const testResults = [
    {resourceCount: 2, timeImprovement: 1.29, memoryImprovement: 1.28, cpuImprovement: 1.10},
    {resourceCount: 4, timeImprovement: 2.12, memoryImprovement: 1.09, cpuImprovement: 0.97},
    {resourceCount: 6, timeImprovement: 2.74, memoryImprovement: 0.62, cpuImprovement: 0.94},
    {resourceCount: 8, timeImprovement: 3.82, memoryImprovement: 1.37, cpuImprovement: 1.19},
    {resourceCount: 10, timeImprovement: 4.44, memoryImprovement: 0.84, cpuImprovement: 0.98},
  ];

  // 리소스 개수별 차트 데이터 준비
  const resourceCounts = testResults.map(r => r.resourceCount);
  const timeImprovementData = testResults.map(r => r.timeImprovement);
  
  // 시간 개선 차트
  new Chart(document.getElementById('timeImprovementChart'), {
    type: 'line',
    data: {
      labels: resourceCounts,
      datasets: [{
        label: '처리 시간 개선',
        data: timeImprovementData,
        borderColor: '#36a2eb',
        backgroundColor: 'rgba(54, 162, 235, 0.2)',
        tension: 0.1
      }]
    },
    options: {
      scales: {
        y: {
          title: {
            display: true,
            text: '시간 개선 (배수)'
          },
          suggestedMin: 1
        },
        x: {
          title: {
            display: true,
            text: '리소스 개수'
          }
        }
      }
    }
  });
});
</script>

<style>
table {
  width: 100%; 
  border-collapse: collapse; 
  margin: 20px 0;
}
table, th, td {
  border: 1px solid #ddd;
}
th, td {
  padding: 4px; 
  text-align: right;
}
th {
  background-color: #f2f2f2;
}
</style>

<table>
  <tr>
    <th>리소스 개수</th>
    <th>전체 처리 시간(ms)</th>
    <th>선택적 처리 시간(ms)</th>
    <th>시간 개선</th>
    <th>메모리 개선</th>
    <th>CPU 개선</th>
  </tr>
  <tr>
    <td>2</td>
    <td>100325</td>
    <td>77813</td>
    <td>1.29배</td>
    <td>1.28배</td>
    <td>1.10배</td>
  </tr>
  <tr>
    <td>4</td>
    <td>158378</td>
    <td>74690</td>
    <td>2.12배</td>
    <td>1.09배</td>
    <td>0.97배</td>
  </tr>
  <tr>
    <td>6</td>
    <td>206643</td>
    <td>75470</td>
    <td>2.74배</td>
    <td>0.62배</td>
    <td>0.94배</td>
  </tr>
  <tr>
    <td>8</td>
    <td>276535</td>
    <td>72399</td>
    <td>3.82배</td>
    <td>1.37배</td>
    <td>1.19배</td>
  </tr>
  <tr>
    <td>10</td>
    <td>351809</td>
    <td>79250</td>
    <td>4.44배</td>
    <td>0.84배</td>
    <td>0.98배</td>
  </tr>
</table>

- 5개의 시나리오에서 '전체 적재'와 '딱 1개만 적재'를 비교했습니다.
- **시간 효율성**: 리소스 개수가 증가할수록 선형적으로 개선됩니다. 리소스가 10개일 때 최대 **4.4배** 개선됩니다.

### iv) 한계
- 파일 시뮬레이션으로 구현했기 때문에, 스프링 환경에서의 트랜잭션 개선사항은 확인하지 못했다는 한계가 있습니다.
- 다양한 수의 column-row를 가진 csv 파일이나, json 파일 등은 확인하지 못했다는 한계가 있습니다.
- 증분 업데이트를 도입하면 효율성을 더 개선할 수 있습니다.

---

# 5. 집순은 어디까지 버틸 수 있을까

- 후술할 2개의 챌린지는 요청을 얼마나 효율적으로 처리하는지에 관한 것입니다.
- 그러므로 집순 서비스의 운영환경을 가정하고, 부하를 추정해 보겠습니다.
- 초당 요청 수(RPS)은 다음 공식으로 계산합니다.

  <span class="math">RPS = \frac{DAU \times RPU \times P_{peak}}{T_{peak}} = \frac{DAU \times 일인당 평균 요청 수 \times 피크 시간대 비율}{피크 시간대 길이(초)}</span>

- 이제 계산에 필요한 각 요소를 가정해 보겠습니다.

### i) DAU: 10만

- 2020년 기준, 안드로이드에서의 호갱노노, 직방 DAU는 각각 30만, 25만 정도입니다.[^1]
- 2024년 기준, 직방에서 배포한 홍보자료에 따르면 호갱노노의 DAU는 53만, 직방은 34만입니다.[^2]
- 집순은 신생 서비스이므로, 직방의 약 1/3인 ***10만 DAU***로 가정하겠습니다.


### ii) RPU: 30회

<table>
    <thead>
        <tr>
            <th>카테고리</th>
            <th>엔드포인트</th>
            <th>요청 횟수/세션</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="4">매물 관련</td>
            <td>GET /estates/map (지도 로딩 및 이동)</td>
            <td>10-15회</td>
        </tr>
        <tr>
            <td>GET /estates/{id} (매물 상세 조회)</td>
            <td>5-8회</td>
        </tr>
        <tr>
            <td>POST /estates/{id}/favorite (찜하기)</td>
            <td>1-2회</td>
        </tr>
        <tr>
            <td>DELETE /estates/{id}/favorite (찜 해제)</td>
            <td>1-2회</td>
        </tr>
        <tr>
            <td rowspan="2">점수 유형</td>
            <td>GET /score-types (점수 유형 조회)</td>
            <td>1-2회</td>
        </tr>
        <tr>
            <td>POST/DELETE /score-types/{id} (활성/비활성)</td>
            <td>1-2회</td>
        </tr>
        <tr>
            <td>사용자</td>
            <td>GET /users/me/favorites (찜 목록 조회)</td>
            <td>1-2회</td>
        </tr>
        <tr>
            <th colspan="2">총 요청 수/세션</th>
            <th><i>20-30회</i></th>
        </tr>
    </tbody>
</table>

- 한 유저가 ***평균 30회정도를 요청***한다고 가정합니다.


### iii) Peak, Time: 0.1, 7200초

- 프롭테크 서비스의 시간-요일-계절별 트래픽 패턴은 알려진 바가 없습니다.
- 다만 이커머스의 경우, 시간대별 구매 패턴이 잘 알려져 있습니다.[^3] 이에 따르면 오전 10시와 12시에 가장 많은 구매가 일어납니다.[^4]
- 이에 따라 ***피크 시간대 비율은 10%***로, ***피크 시간대 길이(초)는 7,200초(2시간)***으로 가정하겠습니다. 간편한 계산을 위해 구매 트래픽을 조회 트래픽으로 단순 변환했습니다.

### iv) 결론

<span class="math">RPS = \frac{100,000 \times 30 \times 0.1}{7,200} = \frac{300,000}{7,200} \approx 41.67</span>

- 집순은 **최대 초당 약 42개의 요청**을 처리할 수 있어야 합니다.
- 여유롭게 설계하기 위해 **목표 RPS는 50**으로 설정하겠습니다.

---

# 6. 챌린지: 포괄적 요청 추적 시스템

(작성중)

---

# 7. 챌린지: 지오스페이셜 쿼리 성능 향상

(작성중)


---

# References


[^1]: [프롭테크 유저 500만 넘었다... 호갱노노-직방-네이버부동산 ‘삼국지’](https://www.bloter.net/news/articleView.html?idxno=34155)

[^2]: [직방/호갱노노 통합 광고상품 소개서](https://adure.net/uploads/adure/1741232115_%EC%A7%81%EB%B0%A9_%ED%98%B8%EA%B0%B1%EB%85%B8%EB%85%B8_%ED%86%B5%ED%95%A9_%EA%B4%91%EA%B3%A0%EC%83%81%ED%92%88_%EC%86%8C%EA%B0%9C%EC%84%9C_v2.5.pdf)

[^3]: [‘월요일 오전 11시·오후 2시’ 온라인쇼핑 가장 많다…왜?](https://www.donga.com/news/Economy/article/all/20211220/110867797/1)

[^4]: <div><span>다음은 3번 참조링크의 추산값입니다.</span><table>
        <thead>
            <tr>
                <th>시간대</th>
                <th>구매 수</th>
                <th>퍼센트(%)</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>0</td><td>37</td><td>4.41</td></tr>
            <tr><td>1</td><td>24</td><td>2.86</td></tr>
            <tr><td>2</td><td>13</td><td>1.55</td></tr>
            <tr><td>3</td><td>10</td><td>1.19</td></tr>
            <tr><td>4</td><td>8</td><td>0.95</td></tr>
            <tr><td>5</td><td>7</td><td>0.83</td></tr>
            <tr><td>6</td><td>10</td><td>1.19</td></tr>
            <tr><td>7</td><td>20</td><td>2.38</td></tr>
            <tr><td>8</td><td>27</td><td>3.22</td></tr>
            <tr><td>9</td><td>35</td><td>4.17</td></tr>
            <tr><td><b><i>10</i></b></td><td><b><i>56</i></b></td><td><b><i>6.67</i></b></td></tr>
            <tr><td>11</td><td>53</td><td>6.32</td></tr>
            <tr><td><b><i>12</i></b></td><td><b><i>56</i></b></td><td><b><i>6.67</i></b></td></tr>
            <tr><td>13</td><td>50</td><td>5.96</td></tr>
            <tr><td>14</td><td>48</td><td>5.72</td></tr>
            <tr><td>15</td><td>46</td><td>5.48</td></tr>
            <tr><td>16</td><td>42</td><td>5.01</td></tr>
            <tr><td>17</td><td>43</td><td>5.13</td></tr>
            <tr><td>18</td><td>37</td><td>4.41</td></tr>
            <tr><td>19</td><td>37</td><td>4.41</td></tr>
            <tr><td>20</td><td>43</td><td>5.13</td></tr>
            <tr><td>21</td><td>46</td><td>5.48</td></tr>
            <tr><td>22</td><td>48</td><td>5.72</td></tr>
            <tr><td>23</td><td>43</td><td>5.13</td></tr>
        </tbody>
    </table></div>